use super::RenderConfig;

/// Status bar layout constants.
pub(crate) const FONT_WIDTH: usize = 7;
pub(crate) const FONT_HEIGHT: usize = 11;
pub(crate) const STATUS_PAD_TOP: usize = 3;
pub(crate) const STATUS_PAD_BOTTOM: usize = 2;
pub(crate) const STATUS_BAR_HEIGHT: usize = STATUS_PAD_TOP + FONT_HEIGHT + STATUS_PAD_BOTTOM;

/// 7x11 bitmap font glyph lookup. Each row is a u8 with lower 7 bits = pixels (bit6=left).
///
/// Layout conventions:
/// - Uppercase / digits: rows 1–8 (8px cap height)
/// - Lowercase (no ascender): rows 3–8
/// - Lowercase (ascender: b,d,f,h,k,l,t): rows 1–8
/// - Descender (g,p,q,y,j): rows 3–10
pub(crate) const fn glyph(ch: u8) -> [u8; FONT_HEIGHT] {
    match ch {
        // ── Symbols ──────────────────────────────────────────────────
        b' ' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'.' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00],
        b'-' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'/' => [0x00, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x00, 0x00],
        b'>' => [0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00],
        b'<' => [0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00],
        b'=' => [0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00],
        b'[' => [0x00, 0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C, 0x00, 0x00],
        b']' => [0x00, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x00, 0x00],
        b'|' => [0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00],
        b':' => [0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00],
        b'+' => [0x00, 0x00, 0x00, 0x00, 0x08, 0x3E, 0x08, 0x00, 0x00, 0x00, 0x00],
        b'(' => [0x00, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10, 0x08, 0x04, 0x00, 0x00],
        b')' => [0x00, 0x10, 0x08, 0x04, 0x04, 0x04, 0x04, 0x08, 0x10, 0x00, 0x00],
        b'*' => [0x00, 0x00, 0x00, 0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00, 0x00, 0x00],
        b'#' => [0x00, 0x00, 0x14, 0x3E, 0x14, 0x14, 0x3E, 0x14, 0x00, 0x00, 0x00],
        b'%' => [0x00, 0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06, 0x00, 0x00, 0x00],
        b',' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00],

        // ── Digits (6px wide: cols 0–5) ────────────────────────────────
        b'0' => [0x00, 0x3C, 0x42, 0x46, 0x4A, 0x52, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'1' => [0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00],
        b'2' => [0x00, 0x3C, 0x42, 0x02, 0x04, 0x08, 0x10, 0x7E, 0x00, 0x00, 0x00],
        b'3' => [0x00, 0x3C, 0x42, 0x02, 0x1C, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'4' => [0x00, 0x04, 0x0C, 0x14, 0x24, 0x7E, 0x04, 0x04, 0x00, 0x00, 0x00],
        b'5' => [0x00, 0x7E, 0x40, 0x7C, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'6' => [0x00, 0x1C, 0x20, 0x40, 0x7C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'7' => [0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00],
        b'8' => [0x00, 0x3C, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'9' => [0x00, 0x3C, 0x42, 0x42, 0x3E, 0x02, 0x04, 0x38, 0x00, 0x00, 0x00],

        // ── Uppercase (6px wide: cols 0–5) ──────────────────────────────
        b'A' => [0x00, 0x18, 0x24, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x00, 0x00, 0x00],
        b'B' => [0x00, 0x7C, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00],
        b'C' => [0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'D' => [0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00],
        b'E' => [0x00, 0x7E, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00],
        b'F' => [0x00, 0x7E, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00],
        b'G' => [0x00, 0x3C, 0x42, 0x40, 0x4E, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'H' => [0x00, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00],
        b'I' => [0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00],
        b'J' => [0x00, 0x1E, 0x04, 0x04, 0x04, 0x04, 0x24, 0x18, 0x00, 0x00, 0x00],
        b'K' => [0x00, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00],
        b'L' => [0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00],
        b'M' => [0x00, 0x42, 0x66, 0x5A, 0x5A, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00],
        b'N' => [0x00, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x42, 0x00, 0x00, 0x00],
        b'O' => [0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'P' => [0x00, 0x7C, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00],
        b'Q' => [0x00, 0x3C, 0x42, 0x42, 0x42, 0x4A, 0x44, 0x3A, 0x00, 0x00, 0x00],
        b'R' => [0x00, 0x7C, 0x42, 0x42, 0x7C, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00],
        b'S' => [0x00, 0x3C, 0x42, 0x40, 0x3C, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'T' => [0x00, 0x7E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00],
        b'U' => [0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00],
        b'V' => [0x00, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x08, 0x00, 0x00, 0x00],
        b'W' => [0x00, 0x42, 0x42, 0x42, 0x5A, 0x5A, 0x66, 0x24, 0x00, 0x00, 0x00],
        b'X' => [0x00, 0x42, 0x24, 0x24, 0x18, 0x24, 0x24, 0x42, 0x00, 0x00, 0x00],
        b'Y' => [0x00, 0x42, 0x42, 0x24, 0x18, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00],
        b'Z' => [0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00, 0x00, 0x00],

        // ── Lowercase ────────────────────────────────────────────────
        b'a' => [0x00, 0x00, 0x00, 0x1C, 0x02, 0x1E, 0x22, 0x22, 0x1E, 0x00, 0x00],
        b'b' => [0x00, 0x20, 0x20, 0x3C, 0x22, 0x22, 0x22, 0x22, 0x3C, 0x00, 0x00],
        b'c' => [0x00, 0x00, 0x00, 0x1C, 0x22, 0x20, 0x20, 0x22, 0x1C, 0x00, 0x00],
        b'd' => [0x00, 0x02, 0x02, 0x1E, 0x22, 0x22, 0x22, 0x22, 0x1E, 0x00, 0x00],
        b'e' => [0x00, 0x00, 0x00, 0x1C, 0x22, 0x3E, 0x20, 0x20, 0x1C, 0x00, 0x00],
        b'f' => [0x00, 0x0C, 0x12, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00],
        b'g' => [0x00, 0x00, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x22, 0x1C],
        b'h' => [0x00, 0x20, 0x20, 0x2C, 0x32, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00],
        b'i' => [0x00, 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00],
        b'j' => [0x00, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x24, 0x18],
        b'k' => [0x00, 0x20, 0x20, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22, 0x00, 0x00],
        b'l' => [0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1C, 0x00, 0x00],
        b'm' => [0x00, 0x00, 0x00, 0x34, 0x2A, 0x2A, 0x2A, 0x22, 0x22, 0x00, 0x00],
        b'n' => [0x00, 0x00, 0x00, 0x2C, 0x32, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00],
        b'o' => [0x00, 0x00, 0x00, 0x1C, 0x22, 0x22, 0x22, 0x22, 0x1C, 0x00, 0x00],
        b'p' => [0x00, 0x00, 0x00, 0x3C, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20],
        b'q' => [0x00, 0x00, 0x00, 0x1E, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x02, 0x02],
        b'r' => [0x00, 0x00, 0x00, 0x2C, 0x32, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00],
        b's' => [0x00, 0x00, 0x00, 0x1C, 0x22, 0x18, 0x0C, 0x22, 0x1C, 0x00, 0x00],
        b't' => [0x00, 0x10, 0x10, 0x3C, 0x10, 0x10, 0x10, 0x12, 0x0C, 0x00, 0x00],
        b'u' => [0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x26, 0x1A, 0x00, 0x00],
        b'v' => [0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x14, 0x08, 0x00, 0x00],
        b'w' => [0x00, 0x00, 0x00, 0x22, 0x22, 0x2A, 0x2A, 0x36, 0x22, 0x00, 0x00],
        b'x' => [0x00, 0x00, 0x00, 0x22, 0x14, 0x08, 0x08, 0x14, 0x22, 0x00, 0x00],
        b'y' => [0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x1E, 0x02, 0x22, 0x1C],
        b'z' => [0x00, 0x00, 0x00, 0x3E, 0x02, 0x04, 0x08, 0x10, 0x3E, 0x00, 0x00],

        _ => [0x00; FONT_HEIGHT],
    }
}

pub(crate) fn draw_char(buf: &mut [u8], frame_width: usize, x: usize, y: usize, ch: u8, color: [u8; 3]) {
    let g = glyph(ch);
    for row in 0..FONT_HEIGHT {
        let bits = g[row];
        for col in 0..FONT_WIDTH {
            if bits & (1 << (FONT_WIDTH - 1 - col)) != 0 {
                let px = x + col;
                let py = y + row;
                let offset = (py * frame_width + px) * 4;
                if offset + 3 < buf.len() {
                    buf[offset] = color[0];
                    buf[offset + 1] = color[1];
                    buf[offset + 2] = color[2];
                    buf[offset + 3] = 255;
                }
            }
        }
    }
}

/// Draw a string of text at (x, y) in the given color. Returns the x position after the last character.
pub(crate) fn draw_text(buf: &mut [u8], frame_width: usize, x: usize, y: usize, text: &str, color: [u8; 3]) -> usize {
    let char_step = FONT_WIDTH + 1;
    let mut cx = x;
    for &ch in text.as_bytes() {
        draw_char(buf, frame_width, cx, y, ch, color);
        cx += char_step;
    }
    cx
}

/// Draw a character at (x, y) resized to target (cw x ch) pixels via nearest-neighbor.
fn draw_char_sized(buf: &mut [u8], frame_width: usize, x: usize, y: usize, ch_code: u8, color: [u8; 3], cw: usize, ch: usize) {
    let g = glyph(ch_code);
    for py in 0..ch {
        let src_row = py * FONT_HEIGHT / ch;
        let bits = g[src_row];
        for px in 0..cw {
            let src_col = px * FONT_WIDTH / cw;
            if bits & (1 << (FONT_WIDTH - 1 - src_col)) != 0 {
                let offset = ((y + py) * frame_width + x + px) * 4;
                if offset + 3 < buf.len() {
                    buf[offset] = color[0];
                    buf[offset + 1] = color[1];
                    buf[offset + 2] = color[2];
                    buf[offset + 3] = 255;
                }
            }
        }
    }
}

/// Draw a string of text at (x, y) with each character sized to (cw x ch) pixels.
/// Returns the x position after the last character.
pub(crate) fn draw_text_sized(buf: &mut [u8], frame_width: usize, x: usize, y: usize, text: &str, color: [u8; 3], cw: usize, ch: usize) -> usize {
    let char_step = cw + cw / 5 + 1; // proportional spacing (~20% of char width)
    let mut cx = x;
    for &byte in text.as_bytes() {
        draw_char_sized(buf, frame_width, cx, y, byte, color, cw, ch);
        cx += char_step;
    }
    cx
}

/// Draw status text at the bottom of the frame buffer.
pub fn render_status(buf: &mut [u8], cfg: &RenderConfig, text: &str) {
    let fw = cfg.frame_width;
    let y_start = cfg.display_height;

    // Fill status bar background (#0D0D0D)
    for y in y_start..cfg.frame_height {
        for x in 0..fw {
            let offset = (y * fw + x) * 4;
            if offset + 3 < buf.len() {
                buf[offset] = 0x0D;
                buf[offset + 1] = 0x0D;
                buf[offset + 2] = 0x0D;
                buf[offset + 3] = 255;
            }
        }
    }

    // Separator line (#333333)
    for x in 0..fw {
        let offset = (y_start * fw + x) * 4;
        if offset + 3 < buf.len() {
            buf[offset] = 0x33;
            buf[offset + 1] = 0x33;
            buf[offset + 2] = 0x33;
            buf[offset + 3] = 255;
        }
    }

    // Draw text
    let text_y = y_start + STATUS_PAD_TOP;
    let text_color: [u8; 3] = [0x88, 0x88, 0x88];
    let char_step = FONT_WIDTH + 1;
    let mut cx = 4 + cfg.display_x_offset; // left padding, aligned with display area
    for &ch in text.as_bytes() {
        if cx + FONT_WIDTH > fw {
            break;
        }
        draw_char(buf, fw, cx, text_y, ch, text_color);
        cx += char_step;
    }
}

/// Draw text with dark shadow for readability over variable backgrounds.
pub(crate) fn draw_text_shadow(buf: &mut [u8], fw: usize, x: usize, y: usize, text: &str, color: [u8; 3]) {
    draw_text(buf, fw, x + 1, y + 1, text, [0, 0, 0]);
    draw_text(buf, fw, x, y, text, color);
}

/// Draw sized text with dark shadow for readability.
pub(crate) fn draw_text_shadow_sized(buf: &mut [u8], fw: usize, x: usize, y: usize, text: &str, color: [u8; 3], cw: usize, ch: usize) {
    draw_text_sized(buf, fw, x + 1, y + 1, text, [0, 0, 0], cw, ch);
    draw_text_sized(buf, fw, x, y, text, color, cw, ch);
}

/// Render a field-name badge at the top-left of the display area.
///
/// Layout:
/// ```text
///   ┌────────────────────────┐
///   │  vort anomaly     1/6  │
///   └────────────────────────┘
/// ```
///
/// This is a shared implementation used by both spherical (playback) and
/// CFD (solver) rendering paths.
pub(crate) fn render_field_badge(
    buf: &mut [u8],
    frame_width: usize,
    display_height: usize,
    display_name: &str,
    field_index: usize,
    field_count: usize,
) {
    let fw = frame_width;

    // Badge font sizes
    let big_cw: usize = 10;
    let big_ch: usize = 15;
    let big_step = big_cw + big_cw / 5 + 1; // matches draw_text_sized spacing
    let small_step = FONT_WIDTH + 1;

    // Index text: "1/6"
    let index_text = format!("{}/{}", field_index + 1, field_count);

    // Compute badge dimensions
    let name_w = display_name.len() * big_step;
    let idx_w = index_text.len() * small_step;
    let gap = big_step; // gap between name and index
    let pad_x: usize = 8;
    let pad_y: usize = 5;

    let content_w = name_w + gap + idx_w;
    let badge_w = pad_x * 2 + content_w;
    let badge_h = pad_y * 2 + big_ch;

    let margin: usize = 10;
    let badge_x = margin;
    let badge_y = margin;

    // Draw semi-transparent dark background (70% alpha blend)
    let bg_r = 10.0_f64;
    let bg_g = 12.0;
    let bg_b = 20.0;
    let alpha = 0.7;

    for y in badge_y..badge_y + badge_h {
        for x in badge_x..badge_x + badge_w {
            if x >= fw || y >= display_height {
                continue;
            }
            let off = (y * fw + x) * 4;
            if off + 3 < buf.len() {
                let r = buf[off] as f64;
                let g = buf[off + 1] as f64;
                let b = buf[off + 2] as f64;
                buf[off] = (r * (1.0 - alpha) + bg_r * alpha) as u8;
                buf[off + 1] = (g * (1.0 - alpha) + bg_g * alpha) as u8;
                buf[off + 2] = (b * (1.0 - alpha) + bg_b * alpha) as u8;
            }
        }
    }

    // Draw field display name (10x15 sized font with shadow)
    let text_x = badge_x + pad_x;
    let text_y = badge_y + pad_y;
    let name_color = [0xCC, 0xCC, 0xD0];
    draw_text_shadow_sized(buf, fw, text_x, text_y, display_name, name_color, big_cw, big_ch);

    // Draw index "1/6" (7x11 native font, dimmer)
    let idx_x = text_x + name_w + gap;
    let idx_y = text_y + (big_ch.saturating_sub(FONT_HEIGHT)) / 2; // vertically center
    let idx_color = [0x55, 0x55, 0x55];
    draw_text(buf, fw, idx_x, idx_y, &index_text, idx_color);
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::state::N;

    fn test_config() -> RenderConfig {
        RenderConfig::fit(542, 512, 3, N)
    }

    #[test]
    fn test_glyph_dash_arrow() {
        // '-' and '>' should have non-zero bitmaps
        let dash = glyph(b'-');
        let has_dash = dash.iter().any(|&row| row != 0);
        assert!(has_dash, "'-' glyph should have non-zero bits");

        let arrow = glyph(b'>');
        let has_arrow = arrow.iter().any(|&row| row != 0);
        assert!(has_arrow, "'>' glyph should have non-zero bits");
    }

    #[test]
    fn test_draw_text_returns_end_position() {
        let cfg = test_config();
        let mut buf = vec![0u8; cfg.frame_width * cfg.frame_height * 4];
        let color = [0xFF, 0xFF, 0xFF];
        let end_x = draw_text(&mut buf, cfg.frame_width, 10, 10, "hello", color);
        // "hello" = 5 chars, each FONT_WIDTH + 1 pixel spacing = 8 * 5 = 40
        let expected = 10 + 5 * (FONT_WIDTH + 1);
        assert_eq!(end_x, expected, "draw_text should return cursor position after text");

        // Verify some pixels were drawn (non-zero in the text area)
        let mut found = false;
        for y in 10..10 + FONT_HEIGHT {
            for x in 10..end_x {
                let off = (y * cfg.frame_width + x) * 4;
                if buf[off] != 0 {
                    found = true;
                    break;
                }
            }
        }
        assert!(found, "draw_text should have drawn some pixels");
    }

    #[test]
    fn test_render_status_draws_text() {
        let cfg = test_config();
        let mut buf = vec![0u8; cfg.frame_width * cfg.frame_height * 4];
        render_status(&mut buf, &cfg, "test");

        // Status area should have non-zero pixels (background + text)
        let status_start = cfg.display_height * cfg.frame_width * 4;
        let status_area = &buf[status_start..];
        let has_content = status_area.iter().any(|&b| b != 0);
        assert!(has_content, "Status bar should have rendered content");
    }

    #[test]
    fn test_render_status_separator_line() {
        let cfg = test_config();
        let mut buf = vec![0u8; cfg.frame_width * cfg.frame_height * 4];
        render_status(&mut buf, &cfg, "hello");

        // First row of status area should be separator (#333333)
        let sep_offset = (cfg.display_height * cfg.frame_width + 0) * 4;
        assert_eq!(buf[sep_offset], 0x33);
        assert_eq!(buf[sep_offset + 1], 0x33);
        assert_eq!(buf[sep_offset + 2], 0x33);
    }

    #[test]
    fn test_uppercase_glyphs_non_empty() {
        for ch in b'A'..=b'Z' {
            let g = glyph(ch);
            let has_bits = g.iter().any(|&row| row != 0);
            assert!(has_bits, "Uppercase '{}' glyph should have non-zero bits", ch as char);
        }
    }

    #[test]
    fn test_all_glyphs_fit_in_7_bits() {
        // Verify no glyph row uses bits above bit 6 (0x40)
        for ch in 0u8..=127 {
            let g = glyph(ch);
            for (row_idx, &row) in g.iter().enumerate() {
                assert!(
                    row & 0x80 == 0,
                    "Glyph '{}' (0x{:02X}) row {} = 0x{:02X} uses bit 7",
                    ch as char, ch, row_idx, row
                );
            }
        }
    }
}
